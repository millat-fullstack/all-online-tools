<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pro Screenshot Editor ‚Äî Fabric.js</title>
<meta name="description" content="Screenshot editor with Fabric.js: upload, draw, text, arrow, highlight, erase, paste, undo/redo, download." />
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/remixicon@4.2.0/fonts/remixicon.css">
<style>
  :root{--primary:#9B6CE3;--bg:#F6F6FB;--card:#fff;--text:#222}
  *{box-sizing:border-box}
  body{font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, Arial; margin:0; background:var(--bg); color:var(--text); padding:18px}
  .wrap{max-width:1200px;margin:0 auto}
  header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
  h1{font-size:1.15rem;color:var(--primary);margin:0}
  .toolbar{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  /* icon-only buttons */
  .icon-btn { width:44px; height:40px; padding:0; border-radius:8px; display:inline-flex; align-items:center; justify-content:center; border:none; cursor:pointer; background:var(--primary); color:#fff; }
  .icon-btn.secondary{background:#fff;color:var(--primary); border:1px solid rgba(155,108,227,0.18)}
  .label-btn { padding:8px 10px;border-radius:8px;border:none;background:var(--primary);color:#fff;font-weight:600;cursor:pointer; display:inline-flex; align-items:center; gap:8px }
  .icon-btn[title]:hover::after, .label-btn[title]:hover::after {
    content:attr(title); position:absolute; transform:translateY(8px); background:#000;color:#fff;font-size:12px;padding:4px 8px;border-radius:4px;margin-top:6px; white-space:nowrap;
  }
  .canvas-container{background:#fff;border-radius:10px;padding:12px;border:1px solid rgba(0,0,0,0.06)}
  canvas{width:100%;height:auto;border-radius:6px; display:block}
  .stage{display:flex;gap:12px}
  .left{flex:1;min-width:400px}
  .right{width:320px}
  .panel{background:#fff;padding:12px;border-radius:10px;border:1px solid rgba(0,0,0,0.06)}
  .panel h3{margin:0 0 8px 0;font-size:0.95rem}
  .field{display:flex;gap:8px;align-items:center;margin:8px 0}
  .field label{width:88px;font-size:0.9rem;color:#444}
  .field input[type="number"], .field input[type="text"], .field input[type="color"], .field select{flex:1;padding:6px;border:1px solid #ddd;border-radius:6px}
  .small{font-size:0.9rem;padding:6px 8px}
  .danger{background:#ff6b6b}
  .muted{color:#666;font-size:0.9rem}
  .toolbar .group{display:flex;gap:8px;align-items:center}
  /* watermark style overlay (centered text) */
  .watermark-note{position:relative; text-align:center; color:#888; margin-top:8px; font-size:0.95rem}
  .help{font-size:0.9rem;color:#666;margin-top:8px}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>üñºÔ∏è Pro Screenshot Editor</h1>
    <div class="toolbar" role="toolbar" aria-label="Editor toolbar">
      <!-- Upload (label with text) -->
      <label class="label-btn secondary" title="Upload image">
        <i class="ri-upload-2-line"></i> Upload
        <input id="fileInput" type="file" accept="image/*" style="display:none">
      </label>

      <!-- Undo / Redo keep text -->
      <button id="undoBtn" class="label-btn secondary" title="Undo"><i class="ri-arrow-go-back-line"></i> Undo</button>
      <button id="redoBtn" class="label-btn secondary" title="Redo"><i class="ri-arrow-go-forward-line"></i> Redo</button>

      <!-- icon-only tool buttons (hover shows name) -->
      <div class="group" style="margin-left:8px">
        <button id="selectBtn" class="icon-btn secondary" title="Select"><i class="ri-cursor-line"></i></button>
        <button id="drawBtn" class="icon-btn" title="Brush"><i class="ri-pencil-line"></i></button>
        <button id="highlightBtn" class="icon-btn" title="Highlight"><i class="ri-mark-pen-line"></i></button>
        <button id="textBtn" class="icon-btn" title="Text"><i class="ri-text"></i></button>
        <button id="rectBtn" class="icon-btn" title="Rectangle"><i class="ri-shape-line"></i></button>
        <button id="circleBtn" class="icon-btn" title="Circle"><i class="ri-checkbox-blank-circle-line"></i></button>
        <button id="arrowBtn" class="icon-btn" title="Arrow"><i class="ri-arrow-right-line"></i></button>
        <button id="eraserBtn" class="icon-btn" title="Eraser"><i class="ri-eraser-line"></i></button>
        <button id="clearBtn" class="icon-btn secondary" title="Clear edits (keeps image)"><i class="ri-delete-bin-line"></i></button>
      </div>

      <!-- download button keep text -->
      <button id="downloadBtn" class="label-btn" title="Download"><i class="ri-download-2-line"></i> Download</button>
    </div>
  </header>

  <div class="stage">
    <div class="left">
      <div class="canvas-container" id="canvasWrap">
        <canvas id="c" width="1000" height="600" aria-label="Screenshot canvas"></canvas>
      </div>
      <div class="watermark-note" id="watermarkNote">Upload or paste screenshot</div>
      <div class="help">Tip: paste (Ctrl/Cmd+V) an image from clipboard or use Upload. Hover icons to see tool names.</div>
    </div>

    <div class="right">
      <div class="panel">
        <h3>üñå Brush Control</h3>
        <div class="field"><label>Size</label><input id="brushSize" type="number" value="4" min="1"></div>
        <div class="field"><label>Color</label><input id="mainColor" type="color" value="#9B6CE3"></div>
        <hr style="margin:10px 0">
        <h3>üéö Object Control</h3>
        <div class="field"><label>Stroke</label><input id="propStroke" type="number" value="2" min="0"></div>
        <div class="field"><label>Font</label><input id="propFont" type="number" value="20" min="6"></div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="deleteBtn" class="small tool-input danger" title="Delete selected"><i class="ri-delete-bin-6-line"></i> Delete</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Your article content (kept as provided) -->
<link rel="stylesheet" href="/toolsarticle/article.css">
<section class="article-section" style="margin-top:28px">
  <div class="article-container">
    <h2>Screenshot Editor ‚Äì Edit Screenshots Online Instantly</h2>
    <p>
      The <strong>Screenshot Editor</strong> is a powerful online tool that lets you edit, crop, annotate, and enhance your screenshots 
      directly from your browser. Whether you need to highlight important details, blur sensitive information, or add notes, 
      this tool makes screenshot editing simple, fast, and professional.
    </p>

    <h3>What is a Screenshot Editor?</h3>
    <p>
      A <strong>Screenshot Editor</strong> allows you to modify your screenshots without installing any software. 
      You can upload any screenshot, make quick edits such as cropping, drawing, adding text, or applying shapes, 
      and download the final image instantly. It‚Äôs perfect for creating tutorials, reports, presentations, or social media visuals.
    </p>

    <h3>Why Use a Screenshot Editor?</h3>
    <p>
      Editing screenshots helps you communicate more effectively. 
      Instead of uploading plain images, you can highlight important areas, annotate key points, 
      and remove unwanted parts ‚Äî all in seconds. 
      The <strong>screenshot editor</strong> is ideal for teachers, developers, marketers, designers, and anyone who frequently works with visuals.
    </p>

    <h3>Benefits of Using a Screenshot Editor</h3>
    <ul>
      <li>Edit screenshots directly in your browser ‚Äî no app needed</li>
      <li>Crop, rotate, and resize screenshots easily</li>
      <li>Add text, arrows, highlights, and shapes</li>
      <li>Blur or hide sensitive information quickly</li>
      <li>Save and download edited images instantly</li>
    </ul>

    <h3>How to Edit a Screenshot?</h3>
    <p>
      Using the <strong>Screenshot Editor</strong> is quick and straightforward:
    </p>
    <ul>
      <li>Upload your screenshot or paste it directly into the tool</li>
      <li>Use editing options to crop, draw, add text, or blur sections</li>
      <li>Preview your changes in real time</li>
      <li>Click ‚ÄúDownload‚Äù to save your edited screenshot</li>
    </ul>
    <p>
      The tool works on all devices and browsers, making it accessible anywhere without installation or account signup.
    </p>

    <h3>Use Cases of Screenshot Editing</h3>
    <p>
      The <strong>Screenshot Editor</strong> is useful for a variety of tasks:
    </p>
    <ul>
      <li>Creating tutorials or guides with highlighted steps</li>
      <li>Reporting bugs with marked details for developers</li>
      <li>Blurring confidential or private information before sharing</li>
      <li>Designing visual explanations for presentations and documents</li>
    </ul>

    <h3>Tips for Best Results</h3>
    <p>
      Keep your annotations clear and concise for better readability. 
      Use consistent colors for highlighting or drawing, and avoid over-editing for a clean professional look. 
      Always export images in optimal formats like JPG or PNG for quality retention.
    </p>

    <h3>Final Thoughts</h3>
    <p>
      The <strong>Screenshot Editor</strong> is the easiest way to edit screenshots online without complex software. 
      Whether for documentation, design, or communication, it gives you all the essential tools in one place. 
      Upload your screenshot, make edits, and download your final image instantly ‚Äî simple, fast, and efficient.
    </p>
  </div>
</section>

<!-- Fabric.js -->
<script src="https://cdn.jsdelivr.net/npm/fabric@5.3.0/dist/fabric.min.js"></script>
<script>
/* =========================
   Editor Script
   ========================= */
const canvas = new fabric.Canvas('c', { selection: false, preserveObjectStacking: true });
let currentTool = 'select';
let undoStack = [], redoStack = [];
let backgroundImage = null;
let watermarkText = null;

// Helpers
function snapshot(){ try { undoStack.push(JSON.stringify(canvas.toDatalessJSON())); if(undoStack.length>50) undoStack.shift(); redoStack = []; } catch(e){} }
function restoreFrom(json){ canvas.loadFromJSON(json, ()=> canvas.renderAll()); }
function hexToRgba(hex, a=1){ if(!hex) return `rgba(0,0,0,${a})`; const h=hex.replace('#',''); const bigint=parseInt(h,16); const r=(bigint>>16)&255; const g=(bigint>>8)&255; const b=bigint&255; return `rgba(${r},${g},${b},${a})`; }

// Elements
const fileInput = document.getElementById('fileInput');
const selectBtn = document.getElementById('selectBtn');
const drawBtn = document.getElementById('drawBtn');
const highlightBtn = document.getElementById('highlightBtn');
const textBtn = document.getElementById('textBtn');
const rectBtn = document.getElementById('rectBtn');
const circleBtn = document.getElementById('circleBtn');
const arrowBtn = document.getElementById('arrowBtn');
const eraserBtn = document.getElementById('eraserBtn');
const clearBtn = document.getElementById('clearBtn');
const undoBtn = document.getElementById('undoBtn');
const redoBtn = document.getElementById('redoBtn');
const downloadBtn = document.getElementById('downloadBtn');

const brushSize = document.getElementById('brushSize');
const mainColor = document.getElementById('mainColor');
const propStroke = document.getElementById('propStroke');
const propFont = document.getElementById('propFont');
const deleteBtn = document.getElementById('deleteBtn');

const watermarkNote = document.getElementById('watermarkNote');

/* ===== Watermark (centered text when no background image) ===== */
function showWatermark(){
  watermarkNote.style.display = 'block';
  if(!watermarkText){
    watermarkText = new fabric.Text('Upload or paste screenshot', {
      left: canvas.getWidth()/2, top: canvas.getHeight()/2,
      originX: 'center', originY: 'center',
      fontSize: 24, fill: '#999', opacity: 0.35, selectable: false, evented: true
    });
    // clicking watermark opens file picker
    watermarkText.on('mousedown', ()=> fileInput.click());
    canvas.add(watermarkText);
    watermarkText.bringToFront();
  } else {
    watermarkText.set({ left: canvas.getWidth()/2, top: canvas.getHeight()/2, opacity:0.35 });
    watermarkText.selectable = false;
    canvas.add(watermarkText);
  }
  canvas.requestRenderAll();
}
function hideWatermark(){
  watermarkNote.style.display = 'none';
  if(watermarkText){
    try{ canvas.remove(watermarkText); } catch(e){}
    watermarkText = null;
  }
}

/* ===== Upload and Paste support ===== */
fileInput.addEventListener('change', handleFileInput);
function handleFileInput(e){
  const f = e.target.files && e.target.files[0]; if(!f) return;
  const reader = new FileReader();
  reader.onload = ev => loadImageToCanvas(ev.target.result);
  reader.readAsDataURL(f);
}

// Paste image support (clipboard)
window.addEventListener('paste', async (evt) => {
  const items = (evt.clipboardData || evt.originalEvent.clipboardData).items;
  if(!items) return;
  for (const it of items){
    if (it.type.indexOf('image') !== -1) {
      const blob = it.getAsFile();
      const url = URL.createObjectURL(blob);
      loadImageToCanvas(url, true);
      evt.preventDefault();
      return;
    }
  }
});

// load image into canvas as background (keeps aspect fit)
function loadImageToCanvas(url, revoke=false){
  fabric.Image.fromURL(url, img => {
    // fit within a default max size but preserve pixel clarity
    const maxW = 1200, maxH = 800;
    const ratio = Math.min(maxW / img.width, maxH / img.height, 1);
    img.scale(ratio);
    canvas.clear(); // remove previous objects (we treat background as single image + annotations)
    backgroundImage = img;
    canvas.setWidth(img.width * ratio);
    canvas.setHeight(img.height * ratio);
    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), { originX:'left', originY:'top' });
    hideWatermark();
    snapshot();
    if(revoke){ try{ URL.revokeObjectURL(url); } catch(e){} }
  }, { crossOrigin: 'anonymous' });
}

/* ===== Tool state and UI ===== */
function setTool(t){
  currentTool = t;
  canvas.isDrawingMode = (t === 'draw' || t === 'highlight');
  // brush config
  if(t === 'draw'){
    canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
    canvas.freeDrawingBrush.width = parseInt(brushSize.value,10) || 4;
    canvas.freeDrawingBrush.color = mainColor.value;
  } else if(t === 'highlight'){
    canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
    canvas.freeDrawingBrush.width = Math.max(8, parseInt(brushSize.value,10) || 12);
    canvas.freeDrawingBrush.color = hexToRgba(mainColor.value, 0.25);
  }
  canvas.selection = (t === 'select');
  // visual indication
  document.querySelectorAll('.toolbar .icon-btn').forEach(b=>b.style.opacity='1');
  const btn = document.getElementById(t+'Btn');
  if(btn) btn.style.opacity = '0.7';
}
selectBtn.addEventListener('click', ()=> setTool('select'));
drawBtn.addEventListener('click', ()=> setTool('draw'));
highlightBtn.addEventListener('click', ()=> setTool('highlight'));
textBtn.addEventListener('click', ()=> setTool('text'));
rectBtn.addEventListener('click', ()=> setTool('rect'));
circleBtn.addEventListener('click', ()=> setTool('circle'));
arrowBtn.addEventListener('click', ()=> setTool('arrow'));
eraserBtn.addEventListener('click', ()=> setTool('eraser'));
clearBtn.addEventListener('click', clearEdits);

/* Make watermark clickable area (also click note) */
watermarkNote.addEventListener('click', ()=> fileInput.click());

/* ===== Shape drawing interactions ===== */
let isDown=false, startX=0, startY=0, tempShape=null;
canvas.on('mouse:down', function(opt){
  const evt = opt.e;
  const pointer = canvas.getPointer(evt);
  startX = pointer.x; startY = pointer.y;
  // if no background image and watermark exists, clicking watermark triggers upload (already handled)
  if(currentTool === 'draw' || currentTool === 'highlight'){
    // pencil mode -> Fabric handles
    return;
  }
  if(currentTool === 'select'){
    // selection is default
    return;
  }
  if(currentTool === 'eraser'){
    // erase object under pointer (if not backgroundImage)
    const target = canvas.findTarget(evt, true);
    if(target && target !== backgroundImage && target !== watermarkText){
      canvas.remove(target);
      canvas.requestRenderAll();
      snapshot();
    }
    // don't start a drag selection
    return;
  }
  isDown = true;
  if(currentTool === 'rect'){
    tempShape = new fabric.Rect({ left: startX, top: startY, originX:'left', originY:'top', width:0, height:0, stroke: mainColor.value, strokeWidth: parseInt(propStroke.value)||2, fill: 'transparent', selectable:false });
    canvas.add(tempShape);
  } else if(currentTool === 'circle'){
    tempShape = new fabric.Ellipse({ left: startX, top: startY, originX:'center', originY:'center', rx:0, ry:0, stroke: mainColor.value, strokeWidth: parseInt(propStroke.value)||2, fill: 'transparent', selectable:false });
    canvas.add(tempShape);
  } else if(currentTool === 'arrow'){
    tempShape = new fabric.Line([startX, startY, startX, startY], { stroke: mainColor.value, strokeWidth: parseInt(propStroke.value)||4, selectable:false });
    canvas.add(tempShape);
  } else if(currentTool === 'text'){
    const itext = new fabric.IText('Text', { left: startX, top: startY, fontFamily: 'Inter, sans-serif', fontSize: parseInt(propFont.value)||20, fill: mainColor.value });
    canvas.add(itext).setActiveObject(itext);
    itext.enterEditing();
    itext.selectAll();
    snapshot();
    isDown = false;
    tempShape = null;
  }
});
canvas.on('mouse:move', function(opt){
  if(!isDown || !tempShape) return;
  const pointer = canvas.getPointer(opt.e);
  const curX = pointer.x, curY = pointer.y;
  if(currentTool === 'rect'){
    const w = Math.abs(curX - startX), h = Math.abs(curY - startY);
    tempShape.set({ left: Math.min(startX, curX), top: Math.min(startY, curY), width: w, height: h });
    tempShape.setCoords();
    canvas.requestRenderAll();
  } else if(currentTool === 'circle'){
    tempShape.set({ left: (startX + curX)/2, top: (startY + curY)/2, rx: Math.abs(curX - startX)/2, ry: Math.abs(curY - startY)/2 });
    tempShape.setCoords();
    canvas.requestRenderAll();
  } else if(currentTool === 'arrow'){
    tempShape.set({ x2: curX, y2: curY });
    tempShape.setCoords();
    canvas.requestRenderAll();
  }
});
canvas.on('mouse:up', function(){
  if(isDown && tempShape){
    tempShape.set({ selectable: true });
    snapshot();
  }
  isDown = false; tempShape = null;
});

/* When a free drawing path created snapshot */
canvas.on('path:created', function(){ snapshot(); });

/* Object changes: keep color/props synced */
canvas.on('selection:created', updateControls);
canvas.on('selection:updated', updateControls);
canvas.on('selection:cleared', clearControls);

function updateControls(){
  const o = canvas.getActiveObject();
  if(!o) return;
  // set stroke & font control values
  if(o.strokeWidth !== undefined) propStroke.value = o.strokeWidth;
  if(o.fontSize !== undefined) propFont.value = o.fontSize;
}
function clearControls(){ propStroke.value = 2; propFont.value = 20; }

/* Apply property changes */
propStroke.addEventListener('change', ()=>{
  const o = canvas.getActiveObject(); if(!o) return;
  o.set('strokeWidth', parseFloat(propStroke.value) || 0);
  canvas.requestRenderAll(); snapshot();
});
propFont.addEventListener('change', ()=>{
  const o = canvas.getActiveObject(); if(!o) return;
  if(o.type === 'i-text' || o.type === 'textbox'){ o.set('fontSize', parseFloat(propFont.value) || 12); canvas.requestRenderAll(); snapshot(); }
});

/* Unified color behavior */
mainColor.addEventListener('change', ()=>{
  const col = mainColor.value;
  // brush updates
  if(canvas.freeDrawingBrush){
    if(currentTool === 'highlight') canvas.freeDrawingBrush.color = hexToRgba(col, 0.25);
    else canvas.freeDrawingBrush.color = col;
  }
  // active object update
  const o = canvas.getActiveObject();
  if(o){
    if(o.type === 'i-text' || o.type === 'textbox') o.set('fill', col);
    else { o.set('stroke', col); if(o.fill && o.fill !== 'transparent') o.set('fill', col); }
    canvas.requestRenderAll();
    snapshot();
  }
});

/* Brush size control */
brushSize.addEventListener('change', ()=> {
  if(canvas.freeDrawingBrush) canvas.freeDrawingBrush.width = parseInt(brushSize.value,10) || 4;
});

/* Delete selected */
deleteBtn.addEventListener('click', ()=>{ const o=canvas.getActiveObject(); if(!o) return; if(o===watermarkText) return; canvas.remove(o); canvas.discardActiveObject(); canvas.requestRenderAll(); snapshot(); });

/* Clear edits but keep background image */
function clearEdits(){
  if(!confirm('Clear all added edits (keep background image)?')) return;
  const bg = canvas.backgroundImage;
  const keepBg = bg ? bg : null;
  // remove everything except background image representation objects (backgroundImage is not in getObjects(), so just remove all)
  canvas.getObjects().slice().forEach(o=>{ canvas.remove(o); });
  // reset background image if we saved it
  if(keepBg){
    canvas.setBackgroundImage(keepBg, canvas.renderAll.bind(canvas));
  }
  // show watermark if no background present
  if(!keepBg) showWatermark();
  canvas.requestRenderAll();
  snapshot();
}

/* Undo / Redo */
undoBtn.addEventListener('click', ()=>{
  if(!undoStack.length) return;
  const state = undoStack.pop();
  redoStack.push(JSON.stringify(canvas.toDatalessJSON()));
  restoreFrom(state);
});
redoBtn.addEventListener('click', ()=>{
  if(!redoStack.length) return;
  const state = redoStack.pop();
  undoStack.push(JSON.stringify(canvas.toDatalessJSON()));
  restoreFrom(state);
});

/* Download */
downloadBtn.addEventListener('click', ()=>{
  // flatten canvas to PNG (with background)
  const dataURL = canvas.toDataURL({ format: 'png', multiplier: 1 });
  const a = document.createElement('a'); a.href = dataURL; a.download = 'screenshot-edited.png'; a.click();
});

/* Keyboard shortcuts */
document.addEventListener('keydown', function(e){
  if((e.ctrlKey||e.metaKey) && e.key.toLowerCase() === 'z'){ e.preventDefault(); undoBtn.click(); }
  if((e.ctrlKey||e.metaKey) && e.key.toLowerCase() === 'y'){ e.preventDefault(); redoBtn.click(); }
  if(e.key === 'Delete' || e.key === 'Backspace'){ const o = canvas.getActiveObject(); if(o && o!==watermarkText){ canvas.remove(o); snapshot(); } }
});

/* Live update on object moving/scaling/rotating */
canvas.on('object:moving', ()=>canvas.requestRenderAll());
canvas.on('object:scaling', ()=>canvas.requestRenderAll());
canvas.on('object:rotating', ()=>canvas.requestRenderAll());

/* Double click text editing */
canvas.on('mouse:dblclick', function(opt){
  const target = opt.target;
  if(target && (target.type === 'i-text' || target.type === 'textbox')){
    target.enterEditing(); target.selectAll();
  }
});

/* when background image is present or not, toggle watermark */
canvas.on('after:render', ()=>{
  // nothing extra here; managed when background set or cleared
});

/* Initialize: show watermark */
showWatermark();
snapshot();

/* On load: support drag & drop image onto canvasWrap */
const canvasWrap = document.getElementById('canvasWrap');
canvasWrap.addEventListener('dragover', e => e.preventDefault());
canvasWrap.addEventListener('drop', e => {
  e.preventDefault();
  const file = e.dataTransfer.files && e.dataTransfer.files[0];
  if(file && file.type && file.type.indexOf('image') !== -1){
    const reader = new FileReader();
    reader.onload = ev => loadImageToCanvas(ev.target.result);
    reader.readAsDataURL(file);
  }
});
</script>
</body>
</html>
